/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <string.h>
#include "pwm.h"
#include "parse.h"
#include "pins.h"
#include "uart.h"
#include "detection.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

volatile uint32_t systime_ms = 0;        // system time (ms)
volatile uint32_t last_time = 0;		 // used for delay_ms()
volatile uint32_t last_systime_ms = 0;	 // used for delay_ms_flag()


void systick_init(){
	uint32_t *pSRVR = (uint32_t *) 0xE000E014;
	uint32_t *pSCSR = (uint32_t *) 0xE000E010;

	*pSRVR &= ~(0x00FFFFFF);
	*pSRVR |= 8000-1;     // Default HSI is 8MHz , so reload register value should be 8000 for 1 ms tick
	*pSCSR |= 1<<1;
	*pSCSR |= 1<<2;
	*pSCSR |= 1<<0;
}

void delay_ms(uint32_t Delay_ms){
	while ((systime_ms - last_time) < Delay_ms);
}

uint8_t delay_ms_flag(uint32_t Delay_ms){

	if ((systime_ms - last_systime_ms) > Delay_ms) return 1;
	return 0;
}


int main(void)
{
	// Initialization
	systick_init();
	pwm_init();
	led_setup();
	uart_init();

	while (1)
	{
		if (delay_ms_flag(1000)){ // to check whether MCU is running properly (can remove it)
			GPIOC_ODR ^= (1<<13);
			last_systime_ms = systime_ms;
		}
		object_detection(); //for updating obj1 and obj2

		if (rxCmd.type == CMD_SINGLE)
		{
			handle_single(rxCmd.single);
		}

		else if (rxCmd.type == CMD_MOTOR){
			if (!((obj1 == 0 && obj2 == 0) || (obj1 == 1 && rxCmd.dir1 != 'F' && obj2 == 0) || (obj2 == 1 && rxCmd.dir1 != 'B' && obj1 == 0))){ // logic to stop movement if object detected
				motor_control(
					rxCmd.dir1, 0,
					rxCmd.dir2, 0
					);
				continue;
			}
			motor_control(
				rxCmd.dir1, rxCmd.val1,
				rxCmd.dir2, rxCmd.val2
				);
		}

	}
}


void SysTick_Handler(void){
	systime_ms++;
}

uint32_t *pDR = (uint32_t*)0x40013804;

void USART1_IRQHandler(){
    uint32_t *pSR = (uint32_t*)0x40013800;


    if (*pSR & (1 << 5))   // RXNE
    {
        char c = (char)(*pDR & 0xFF);

        /* --- SINGLE CHARACTER COMMAND --- */
        if (isSingleCommand(c))
        {
            rxCmd.type = CMD_SINGLE;
            rxCmd.single = c;
            return;
        }

        /* --- MOTOR COMMAND FRAME --- */

        if((c == 'F')||(c == 'B'))
        {
        	rxIndex = 0;
        }

		rxBuf[rxIndex] = c;
		rxIndex++;

        if (rxIndex >= 6)     // F99R60 â†’ 6 chars
        {
        	rxIndex = 0;
        	parseMotorCommand();
        	memset(rxBuf,0,RX_BUF_SIZE);

        }
    }
}
